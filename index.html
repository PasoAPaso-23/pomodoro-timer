<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horizon Focus</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #222;
            --text-color: white;
            --panel-bg: rgba(255, 255, 255, 0.1);
            --panel-border: rgba(255, 255, 255, 0.2);
            --btn-primary-bg: rgba(255, 255, 255, 0.9);
            --btn-primary-text: #333;
            --progress-track: rgba(255, 255, 255, 0.1);
            --progress-bar: rgba(255, 255, 255, 0.9);
        }

        /* Theme: Simple */
        [data-theme="simple"] {
            --bg-color: #f8f9fa;
            --text-color: #2d3748;
            --panel-bg: rgba(255, 255, 255, 0.8);
            --panel-border: rgba(0, 0, 0, 0.1);
            --btn-primary-bg: #2d3748;
            --btn-primary-text: white;
            --progress-track: rgba(0, 0, 0, 0.1);
            --progress-bar: #2d3748;
        }
        [data-theme="simple"] #canvas-container { display: none; }
        [data-theme="simple"] .btn-glass { 
            background: rgba(0, 0, 0, 0.05); 
            border-color: rgba(0,0,0,0.1);
        }
        [data-theme="simple"] .btn-glass:hover { background: rgba(0, 0, 0, 0.1); }
        [data-theme="simple"] input, [data-theme="simple"] select {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #333;
        }

        /* Theme: Dark */
        [data-theme="dark"] {
            --bg-color: #121212;
            --text-color: #e2e8f0;
            --panel-bg: rgba(255, 255, 255, 0.05);
            --panel-border: rgba(255, 255, 255, 0.1);
            --btn-primary-bg: #e2e8f0;
            --btn-primary-text: #121212;
            --progress-track: rgba(255, 255, 255, 0.1);
            --progress-bar: #e2e8f0;
        }
        [data-theme="dark"] #canvas-container { display: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.5s, color 0.5s;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transition: opacity 0.5s;
        }

        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }

        .btn-glass {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid var(--panel-border);
            transition: all 0.3s ease;
        }
        [data-theme="simple"] .btn-glass svg { color: #333; }
        
        .btn-glass:hover {
            transform: translateY(-2px);
        }
        .btn-primary {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            font-weight: 600;
        }

        input, select {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: inherit;
            padding: 0.5rem;
            border-radius: 0.5rem;
            width: 100%;
        }
        input:focus, select:focus {
            outline: none;
            border-color: rgba(100, 100, 100, 0.8);
        }
        
        /* Toggle Switch Animation Fix */
        .toggle-wrapper {
            position: relative;
            display: inline-block;
            width: 2.75rem;
            height: 1.5rem;
        }
        .toggle-checkbox {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-track {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(156, 163, 175, 0.5);
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-track:before {
            position: absolute;
            content: "";
            height: 1.1rem;
            width: 1.1rem;
            left: 0.2rem;
            bottom: 0.2rem;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        .toggle-checkbox:checked + .toggle-track {
            background-color: #68D391;
        }
        .toggle-checkbox:checked + .toggle-track:before {
            transform: translateX(1.25rem);
        }

        .phase-indicator {
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-size: 0.85rem;
            opacity: 0.9;
        }

        /* Circular Progress */
        .progress-ring__circle {
            transition: stroke-dashoffset 1s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            stroke: var(--progress-bar);
        }
        .progress-ring__bg {
            stroke: var(--progress-track);
        }
    </style>
</head>
<body class="h-screen w-screen flex items-center justify-center">

    <div id="canvas-container">
        <canvas id="bgCanvas"></canvas>
    </div>

    <div id="app" class="relative z-10 w-full max-w-md p-6 mx-4">
        
        <div class="glass-panel rounded-3xl p-8 text-center mb-6 relative">
            
            <!-- Circular Timer Container -->
            <div class="relative w-64 h-64 mx-auto mb-6 flex items-center justify-center">
                <!-- SVG Ring -->
                <svg class="absolute top-0 left-0 w-full h-full" width="256" height="256" viewBox="0 0 256 256">
                    <circle class="progress-ring__bg" stroke-width="6" fill="transparent" r="120" cx="128" cy="128" />
                    <circle id="progress-ring" class="progress-ring__circle" stroke-width="6" fill="transparent" r="120" cx="128" cy="128" stroke-dasharray="753.98" stroke-dashoffset="0" stroke-linecap="round"/>
                </svg>

                <!-- Timer Text (Centered) -->
                <div class="relative z-10 flex flex-col items-center justify-center">
                    <div id="phase-label" class="phase-indicator mb-1 text-xs opacity-80">READY</div>
                    <div id="timer-display" class="text-5xl font-light tracking-wider tabular-nums">25:00</div>
                    <div class="flex items-center gap-1 mt-2 text-xs opacity-70">
                        <span>SET</span>
                        <span id="current-set" class="font-bold text-sm">1</span>
                        <span>/</span>
                        <span id="target-set">5</span>
                    </div>
                </div>
            </div>

            <div class="flex justify-center gap-4">
                <button id="btn-toggle" class="btn-primary rounded-full w-14 h-14 flex items-center justify-center shadow-lg hover:scale-105 transition-transform">
                    <svg id="icon-play" class="w-6 h-6 ml-1" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="icon-pause" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                </button>
                <button id="btn-reset" class="btn-glass rounded-full w-14 h-14 flex items-center justify-center">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>
                </button>
                <button id="btn-settings" class="btn-glass rounded-full w-14 h-14 flex items-center justify-center">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                </button>
            </div>
        </div>

        <div id="status-message" class="text-center text-sm opacity-0 transition-opacity duration-500 h-6">
            設定変更はリセットが必要です
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black/60 backdrop-blur-sm opacity-0 transition-opacity duration-300">
        <div class="glass-panel w-full max-w-sm rounded-2xl p-6 mx-4 transform scale-95 transition-transform duration-300 max-h-[90vh] overflow-y-auto" id="settings-content">
            <h2 class="text-xl font-bold mb-4 text-center">設定</h2>
            
            <div class="space-y-4">
                <!-- Theme -->
                <div>
                    <label class="block text-xs mb-1 opacity-80">テーマ</label>
                    <select id="input-theme">
                        <option value="horizon">Horizon (アニメーション)</option>
                        <option value="simple">Simple (ライト)</option>
                        <option value="dark">Dark (ダーク)</option>
                    </select>
                </div>

                <!-- Basic Timers -->
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs mb-1 opacity-80">集中時間 (分)</label>
                        <input type="number" id="input-focus" value="25" min="1" max="60">
                    </div>
                    <div>
                        <label class="block text-xs mb-1 opacity-80">目標セット数</label>
                        <input type="number" id="input-target" value="5" min="2" max="20">
                    </div>
                </div>

                <div>
                    <label class="block text-xs mb-1 opacity-80">短休憩 (分)</label>
                    <input type="number" id="input-short" value="5" min="1" max="30">
                </div>

                <!-- Long Break Section -->
                <div class="pt-2 border-t border-gray-500/30">
                    <div class="flex items-center justify-between py-2">
                        <span class="text-sm">長休憩を有効にする</span>
                        <label class="toggle-wrapper">
                            <input type="checkbox" id="input-long-enabled" class="toggle-checkbox" checked>
                            <span class="toggle-track"></span>
                        </label>
                    </div>

                    <!-- Long Break Details (Grouped) -->
                    <div id="long-break-container" class="space-y-4 transition-all duration-300 overflow-hidden" style="max-height: 200px; opacity: 1;">
                        <div class="grid grid-cols-2 gap-4 mt-2">
                            <div>
                                <label class="block text-xs mb-1 opacity-80">長休憩 (分)</label>
                                <input type="number" id="input-long" value="15" min="1" max="60">
                            </div>
                            <div>
                                <label class="block text-xs mb-1 opacity-80">頻度 (セット毎)</label>
                                <input type="number" id="input-freq" value="4" min="2">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sound Settings -->
                <div class="pt-2 border-t border-gray-500/30">
                    <h3 class="text-sm font-semibold mb-3 opacity-90">サウンド設定</h3>
                    
                    <div class="mb-4">
                        <label class="block text-xs mb-1 opacity-80">BGMソース</label>
                        <select id="input-bgm-source" class="mb-2">
                            <option value="none">BGMなし</option>
                            <option value="procedural">環境音 (風)</option>
                            <option value="file">ローカルファイル</option>
                        </select>
                        
                        <div id="file-upload-container" class="hidden">
                            <input type="file" id="input-audio-file" accept="audio/*" class="text-xs w-full bg-white/10 rounded p-1">
                        </div>
                    </div>

                    <div class="mb-2">
                        <label class="block text-xs mb-1 opacity-80">通知音タイプ</label>
                        <select id="input-sound-type">
                            <option value="crystal">Crystal (クリスタル)</option>
                            <option value="bowl">Singing Bowl (ボウル)</option>
                            <option value="ripple">Ripple (波紋)</option>
                        </select>
                    </div>

                    <div class="mt-2">
                        <label class="block text-xs mb-1 opacity-80">通知音の長さ: <span id="display-sound-duration">3</span>秒</label>
                        <input type="range" id="input-sound-duration" min="1" max="10" step="0.5" value="3" class="w-full h-2 bg-gray-500/50 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <button id="btn-test-sound" class="mt-3 w-full py-2 text-xs border border-gray-500/50 rounded hover:bg-white/10 transition-colors">
                        通知音をテスト再生
                    </button>
                </div>
            </div>

            <div class="mt-6 flex justify-end gap-3 pt-4 border-t border-gray-500/30">
                <button id="btn-cancel-settings" class="px-4 py-2 rounded-lg hover:bg-white/10 text-sm">キャンセル</button>
                <button id="btn-save-settings" class="px-6 py-2 btn-primary rounded-lg text-sm shadow-lg">保存</button>
            </div>
        </div>
    </div>

    <!-- Confirm Reset Modal -->
    <div id="confirm-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black/60 backdrop-blur-sm">
        <div class="glass-panel w-full max-w-xs rounded-2xl p-6 text-center">
            <h3 class="text-lg font-bold mb-2">リセットしますか？</h3>
            <p class="text-sm opacity-80 mb-6">設定を変更するにはリセットが必要です。</p>
            <div class="flex justify-center gap-3">
                <button id="btn-no-reset" class="px-4 py-2 rounded-lg hover:bg-white/10 text-sm">キャンセル</button>
                <button id="btn-yes-reset" class="px-6 py-2 bg-red-500/80 hover:bg-red-500 text-white font-bold rounded-lg text-sm shadow-lg">リセット</button>
            </div>
        </div>
    </div>

    <!-- Hidden audio element for custom file -->
    <audio id="custom-audio-player" loop class="hidden"></audio>

    <script>
        /**
         * WORKER SCRIPT (Background Timer)
         */
        const workerBlob = new Blob([`
            let timerId;
            self.onmessage = function(e) {
                if (e.data === 'start') {
                    if (timerId) clearInterval(timerId);
                    timerId = setInterval(() => postMessage('tick'), 1000);
                } else if (e.data === 'stop') {
                    clearInterval(timerId);
                    timerId = null;
                }
            };
        `], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        const timerWorker = new Worker(workerUrl);

        /**
         * SOUND ENGINE
         */
        class SoundEngine {
            constructor() {
                this.ctx = null;
                this.bgmNodes = [];
                this.bgmGain = null;
                this.fileAudio = document.getElementById('custom-audio-player');
                this.isPlayingProcedural = false;
            }

            init() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            startBGM(sourceType) {
                this.init();
                this.stopBGM();

                if (sourceType === 'procedural') {
                    this.playProceduralBGM();
                } else if (sourceType === 'file') {
                    if (this.fileAudio.src) {
                        this.fileAudio.play().catch(e => console.log('Audio Play blocked', e));
                    }
                }
            }

            stopBGM() {
                if (this.isPlayingProcedural && this.bgmGain) {
                    const now = this.ctx.currentTime;
                    this.bgmGain.gain.setValueAtTime(this.bgmGain.gain.value, now);
                    this.bgmGain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                    setTimeout(() => {
                        this.bgmNodes.forEach(n => { try { n.stop(); n.disconnect(); } catch(e){} });
                        this.bgmNodes = [];
                        this.isPlayingProcedural = false;
                    }, 1000);
                }
                this.fileAudio.pause();
                this.fileAudio.currentTime = 0;
            }

            playProceduralBGM() {
                if (this.isPlayingProcedural) return;
                this.isPlayingProcedural = true;

                this.bgmGain = this.ctx.createGain();
                this.bgmGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.bgmGain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 3);
                this.bgmGain.connect(this.ctx.destination);

                const bufferSize = 2 * this.ctx.sampleRate;
                const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5; 
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.value = 400;
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 0.15;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 300;
                lfo.connect(lfoGain);
                lfoGain.connect(noiseFilter.frequency);
                noise.connect(noiseFilter);
                noiseFilter.connect(this.bgmGain);
                noise.start();
                lfo.start();
                this.bgmNodes.push(noise, lfo);
            }

            playNotification(type, durationSec) {
                this.init();
                const now = this.ctx.currentTime;
                const dur = Math.max(1, durationSec);

                if (type === 'crystal') {
                    this.makeSound(now, dur, 523.25, 'sine', 1046, 0.1);
                } else if (type === 'bowl') {
                    this.makeSound(now, dur * 1.5, 180, 'sine', 182, 0.5);
                    this.makeSound(now, dur * 1.5, 540, 'sine', 540, 0.2);
                } else if (type === 'ripple') {
                    [0, 0.2, 0.4].forEach((delay, i) => {
                        this.makeSound(now + delay, dur, 880 + (i*200), 'triangle', 880, 0.05);
                    });
                }
            }

            makeSound(startTime, duration, freq, type, modFreq, volume) {
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, startTime);
                osc.frequency.exponentialRampToValueAtTime(modFreq, startTime + 0.1);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(volume, startTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(startTime);
                osc.stop(startTime + duration + 1);
            }
        }

        const audio = new SoundEngine();

        /**
         * STATE & LOGIC
         */
        const PRESETS = {
            focus: 25, shortBreak: 5, longBreak: 15,
            targetSets: 5, longBreakEnabled: true, longBreakFreq: 4,
            bgmSource: 'none', 
            soundType: 'crystal',
            soundDuration: 3,
            theme: 'horizon'
        };

        const PHASE = { FOCUS: 'FOCUS', SHORT_BREAK: 'SHORT_BREAK', LONG_BREAK: 'LONG_BREAK', COMPLETED: 'COMPLETED' };
        const STATUS = { STOPPED: 'STOPPED', RUNNING: 'RUNNING', PAUSED: 'PAUSED' };

        const appState = {
            config: { ...PRESETS },
            status: STATUS.STOPPED,
            phase: PHASE.FOCUS,
            currentSet: 1,
            remainingTime: PRESETS.focus * 60,
            totalTime: PRESETS.focus * 60 // For progress calculation
        };

        function switchPhase() {
            audio.playNotification(appState.config.soundType, appState.config.soundDuration);

            if (appState.phase === PHASE.FOCUS) {
                if (appState.currentSet >= appState.config.targetSets) {
                    completeAll();
                    return;
                }
                const isLong = appState.config.longBreakEnabled && (appState.currentSet % appState.config.longBreakFreq === 0);
                appState.phase = isLong ? PHASE.LONG_BREAK : PHASE.SHORT_BREAK;
                const duration = (isLong ? appState.config.longBreak : appState.config.shortBreak) * 60;
                appState.remainingTime = duration;
                appState.totalTime = duration;
            } else {
                appState.currentSet++;
                appState.phase = PHASE.FOCUS;
                const duration = appState.config.focus * 60;
                appState.remainingTime = duration;
                appState.totalTime = duration;
            }
            updateUI();
            updateVisualTheme();
        }

        function completeAll() {
            stopTimerLogic();
            appState.phase = PHASE.COMPLETED;
            appState.remainingTime = 0;
            appState.totalTime = 1; // Avoid divide by zero
            updateUI();
            updateVisualTheme();
        }

        timerWorker.onmessage = function(e) {
            if (e.data === 'tick') {
                if (appState.remainingTime > 0) {
                    appState.remainingTime--;
                    updateTimerDisplay();
                } else {
                    switchPhase();
                }
            }
        };

        function startTimerLogic() {
            if (appState.status === STATUS.RUNNING) return;
            audio.init();
            if (appState.config.bgmSource !== 'none') {
                audio.startBGM(appState.config.bgmSource);
            }
            if (appState.phase === PHASE.COMPLETED) resetLogic();
            appState.status = STATUS.RUNNING;
            timerWorker.postMessage('start');
            updateUI();
        }

        function pauseTimerLogic() {
            appState.status = STATUS.PAUSED;
            timerWorker.postMessage('stop');
            audio.stopBGM();
            updateUI();
        }

        function stopTimerLogic() {
            appState.status = STATUS.STOPPED;
            timerWorker.postMessage('stop');
            audio.stopBGM();
        }

        function resetLogic() {
            stopTimerLogic();
            appState.phase = PHASE.FOCUS;
            appState.currentSet = 1;
            appState.remainingTime = appState.config.focus * 60;
            appState.totalTime = appState.config.focus * 60;
            updateUI();
            updateVisualTheme();
        }

        /**
         * UI & SETTINGS
         */
        const els = {
            timerDisplay: document.getElementById('timer-display'),
            phaseLabel: document.getElementById('phase-label'),
            currentSet: document.getElementById('current-set'),
            targetSet: document.getElementById('target-set'),
            progressRing: document.getElementById('progress-ring'),
            
            btnToggle: document.getElementById('btn-toggle'),
            iconPlay: document.getElementById('icon-play'),
            iconPause: document.getElementById('icon-pause'),
            btnReset: document.getElementById('btn-reset'),
            btnSettings: document.getElementById('btn-settings'),
            
            modalSettings: document.getElementById('settings-modal'),
            modalContent: document.getElementById('settings-content'),
            modalConfirm: document.getElementById('confirm-modal'),
            
            inputs: {
                theme: document.getElementById('input-theme'),
                focus: document.getElementById('input-focus'),
                short: document.getElementById('input-short'),
                long: document.getElementById('input-long'),
                target: document.getElementById('input-target'),
                freq: document.getElementById('input-freq'),
                longEnabled: document.getElementById('input-long-enabled'),
                longContainer: document.getElementById('long-break-container'),
                bgmSource: document.getElementById('input-bgm-source'),
                fileContainer: document.getElementById('file-upload-container'),
                audioFile: document.getElementById('input-audio-file'),
                soundType: document.getElementById('input-sound-type'),
                soundDuration: document.getElementById('input-sound-duration'),
                soundDurationDisplay: document.getElementById('display-sound-duration')
            },
            btnSave: document.getElementById('btn-save-settings'),
            btnCancel: document.getElementById('btn-cancel-settings'),
            btnYesReset: document.getElementById('btn-yes-reset'),
            btnNoReset: document.getElementById('btn-no-reset'),
            btnTestSound: document.getElementById('btn-test-sound')
        };

        function formatTime(s) {
            return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
        }

        // Circle Params
        const circleRadius = 120;
        const circleCircumference = 2 * Math.PI * circleRadius;
        // els.progressRing.style.strokeDasharray = `${circleCircumference} ${circleCircumference}`;

        function updateTimerDisplay() {
            els.timerDisplay.textContent = formatTime(appState.remainingTime);
            document.title = `${formatTime(appState.remainingTime)} - Horizon Focus`;

            // Progress Ring Calculation
            const progress = appState.remainingTime / appState.totalTime;
            const offset = circleCircumference * (1 - progress);
            els.progressRing.style.strokeDashoffset = offset;
        }

        function updateUI() {
            updateTimerDisplay();
            els.currentSet.textContent = appState.currentSet;
            els.targetSet.textContent = appState.config.targetSets;
            
            const phaseMap = {
                [PHASE.FOCUS]: "FOCUS TIME",
                [PHASE.SHORT_BREAK]: "SHORT BREAK",
                [PHASE.LONG_BREAK]: "LONG BREAK",
                [PHASE.COMPLETED]: "ALL COMPLETED"
            };
            els.phaseLabel.textContent = phaseMap[appState.phase];

            if (appState.status === STATUS.RUNNING) {
                els.iconPlay.classList.add('hidden');
                els.iconPause.classList.remove('hidden');
            } else {
                els.iconPlay.classList.remove('hidden');
                els.iconPause.classList.add('hidden');
            }
        }

        // Events
        els.btnToggle.addEventListener('click', () => {
            appState.status === STATUS.RUNNING ? pauseTimerLogic() : startTimerLogic();
        });
        els.btnReset.addEventListener('click', resetLogic);
        
        els.btnSettings.addEventListener('click', () => {
            if (appState.status === STATUS.RUNNING || appState.status === STATUS.PAUSED) {
                if (appState.currentSet > 1 || appState.remainingTime < appState.config.focus * 60) {
                    els.modalConfirm.classList.remove('hidden');
                    return;
                }
            }
            openSettings();
        });

        els.btnYesReset.addEventListener('click', () => {
            resetLogic();
            els.modalConfirm.classList.add('hidden');
            openSettings();
        });
        els.btnNoReset.addEventListener('click', () => els.modalConfirm.classList.add('hidden'));

        els.inputs.bgmSource.addEventListener('change', (e) => {
            els.inputs.fileContainer.classList.toggle('hidden', e.target.value !== 'file');
        });

        els.inputs.audioFile.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                audio.fileAudio.src = url;
            }
        });

        els.inputs.soundDuration.addEventListener('input', (e) => {
            els.inputs.soundDurationDisplay.textContent = e.target.value;
        });

        els.btnTestSound.addEventListener('click', () => {
            const type = els.inputs.soundType.value;
            const dur = parseFloat(els.inputs.soundDuration.value);
            audio.playNotification(type, dur);
        });

        function openSettings() {
            els.inputs.theme.value = appState.config.theme;
            els.inputs.focus.value = appState.config.focus;
            els.inputs.short.value = appState.config.shortBreak;
            els.inputs.long.value = appState.config.longBreak;
            els.inputs.target.value = appState.config.targetSets;
            els.inputs.freq.value = appState.config.longBreakFreq;
            els.inputs.longEnabled.checked = appState.config.longBreakEnabled;
            els.inputs.bgmSource.value = appState.config.bgmSource;
            els.inputs.soundType.value = appState.config.soundType;
            els.inputs.soundDuration.value = appState.config.soundDuration;
            els.inputs.soundDurationDisplay.textContent = appState.config.soundDuration;

            els.inputs.fileContainer.classList.toggle('hidden', appState.config.bgmSource !== 'file');
            toggleLongBreakContainer();
            
            els.modalSettings.classList.remove('hidden');
            setTimeout(() => {
                els.modalSettings.classList.remove('opacity-0');
                els.modalContent.classList.remove('scale-95');
            }, 10);
        }

        els.btnSave.addEventListener('click', () => {
            const newConfig = {
                theme: els.inputs.theme.value,
                focus: parseInt(els.inputs.focus.value),
                shortBreak: parseInt(els.inputs.short.value),
                longBreak: parseInt(els.inputs.long.value),
                targetSets: parseInt(els.inputs.target.value),
                longBreakFreq: parseInt(els.inputs.freq.value),
                longBreakEnabled: els.inputs.longEnabled.checked,
                bgmSource: els.inputs.bgmSource.value,
                soundType: els.inputs.soundType.value,
                soundDuration: parseFloat(els.inputs.soundDuration.value)
            };

            if (newConfig.targetSets < 2) newConfig.targetSets = 2;
            if (newConfig.longBreakFreq >= newConfig.targetSets) newConfig.longBreakFreq = newConfig.targetSets - 1;

            appState.config = newConfig;
            
            document.body.setAttribute('data-theme', appState.config.theme);
            if (appState.config.theme === 'horizon') resize();

            if (appState.status === STATUS.STOPPED) {
                appState.remainingTime = appState.config.focus * 60;
                appState.totalTime = appState.config.focus * 60;
                updateTimerDisplay();
            }
            updateUI();
            
            els.modalSettings.classList.add('opacity-0');
            els.modalContent.classList.add('scale-95');
            setTimeout(() => els.modalSettings.classList.add('hidden'), 300);
        });
        
        els.btnCancel.addEventListener('click', () => {
            els.modalSettings.classList.add('opacity-0');
            els.modalContent.classList.add('scale-95');
            setTimeout(() => els.modalSettings.classList.add('hidden'), 300);
        });

        els.inputs.longEnabled.addEventListener('change', toggleLongBreakContainer);
        function toggleLongBreakContainer() {
            const enabled = els.inputs.longEnabled.checked;
            if (enabled) {
                els.inputs.longContainer.style.maxHeight = '200px';
                els.inputs.longContainer.style.opacity = '1';
                els.inputs.longContainer.style.pointerEvents = 'auto';
            } else {
                els.inputs.longContainer.style.maxHeight = '0px';
                els.inputs.longContainer.style.opacity = '0';
                els.inputs.longContainer.style.pointerEvents = 'none';
            }
        }

        /**
         * VISUALS (CANVAS)
         */
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        const PALETTES = {
            FOCUS: { skyTop: '#4e95a5', skyBottom: '#f5cba7', mountains: ['#2c6e80', '#255866', '#1a404b', '#122c34'] },
            SHORT_BREAK: { skyTop: '#4b3f72', skyBottom: '#ff9a8b', mountains: ['#423864', '#362d53', '#2a2241', '#1e1830'] },
            LONG_BREAK: { skyTop: '#0f172a', skyBottom: '#1e293b', mountains: ['#1e293b', '#162030', '#0f172a', '#020617'] },
            COMPLETED: { skyTop: '#76b852', skyBottom: '#8dc26f', mountains: ['#5a8f3d', '#497531', '#375924', '#263d18'] }
        };

        let currentPalette = PALETTES.FOCUS;
        let targetPalette = PALETTES.FOCUS;
        let transitionProgress = 1;
        let layers = [];

        class Layer {
            constructor(yOffset, colorIndex, speed, amplitude, noise) {
                this.yOffset = yOffset;
                this.colorIndex = colorIndex;
                this.speed = speed;
                this.amplitude = amplitude;
                this.noise = noise;
                this.offset = 0;
                this.initPoints();
            }
            initPoints() {
                this.points = [];
                let x = 0;
                while(x < width + 500) {
                    const step = 50 + Math.random() * this.noise;
                    const y = (height * (1 - this.yOffset)) - (Math.random() * this.amplitude);
                    this.points.push({x, y});
                    x += step;
                }
            }
            update() {
                this.offset -= this.speed;
                if (this.points[0].x + this.offset < -200) {
                    const first = this.points.shift();
                    const last = this.points[this.points.length - 1];
                    const step = 50 + Math.random() * this.noise;
                    first.x = last.x + step;
                    first.y = (height * (1 - this.yOffset)) - (Math.random() * this.amplitude);
                    this.points.push(first);
                }
            }
            draw(ctx, palette) {
                ctx.fillStyle = palette.mountains[this.colorIndex];
                ctx.beginPath();
                ctx.moveTo(this.points[0].x + this.offset, height);
                this.points.forEach(p => ctx.lineTo(p.x + this.offset, p.y));
                ctx.lineTo(this.points[this.points.length - 1].x + this.offset, height);
                ctx.fill();
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            layers = [
                new Layer(0.6, 0, 0.2, height * 0.3, 200),
                new Layer(0.4, 1, 0.4, height * 0.2, 150),
                new Layer(0.2, 2, 0.8, height * 0.15, 100),
                new Layer(0.0, 3, 1.2, height * 0.1, 50)
            ];
        }
        window.addEventListener('resize', resize);
        resize();

        function lerpColor(a, b, amount) { 
            const ah = parseInt(a.replace(/#/g,''),16), ar=ah>>16, ag=ah>>8&0xff, ab=ah&0xff;
            const bh = parseInt(b.replace(/#/g,''),16), br=bh>>16, bg=bh>>8&0xff, bb=bh&0xff;
            const rr=ar+amount*(br-ar), rg=ag+amount*(bg-ag), rb=ab+amount*(bb-ab);
            return '#' + ((1<<24)+(rr<<16)+(rg<<8)+rb|0).toString(16).slice(1);
        }

        function getInterpolatedPalette() {
            if (transitionProgress >= 1) return targetPalette;
            const p = {};
            p.skyTop = lerpColor(currentPalette.skyTop, targetPalette.skyTop, transitionProgress);
            p.skyBottom = lerpColor(currentPalette.skyBottom, targetPalette.skyBottom, transitionProgress);
            p.mountains = currentPalette.mountains.map((c, i) => lerpColor(c, targetPalette.mountains[i], transitionProgress));
            return p;
        }

        function updateVisualTheme() {
            currentPalette = getInterpolatedPalette();
            transitionProgress = 0;
            switch (appState.phase) {
                case PHASE.FOCUS: targetPalette = PALETTES.FOCUS; break;
                case PHASE.SHORT_BREAK: targetPalette = PALETTES.SHORT_BREAK; break;
                case PHASE.LONG_BREAK: targetPalette = PALETTES.LONG_BREAK; break;
                case PHASE.COMPLETED: targetPalette = PALETTES.COMPLETED; break;
            }
        }

        function animate() {
            if (appState.config.theme !== 'horizon') {
                requestAnimationFrame(animate);
                return;
            }

            ctx.clearRect(0, 0, width, height);
            if (transitionProgress < 1) transitionProgress += 0.005;
            
            const activePalette = getInterpolatedPalette();
            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, activePalette.skyTop);
            grad.addColorStop(1, activePalette.skyBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            layers.forEach(layer => {
                if (appState.status === STATUS.RUNNING) layer.update();
                layer.draw(ctx, activePalette);
            });
            requestAnimationFrame(animate);
        }
        animate();
        
        // Initial set
        document.body.setAttribute('data-theme', 'horizon');
        updateUI();

    </script>
</body>
</html>